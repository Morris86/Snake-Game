@page "/snake"
@rendermode InteractiveServer
@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using System.Numerics
@using System.Diagnostics
@using System.Text.Json
@using CS3500.NetworkController
@using CS3500.Models
@inject IJSRuntime JsRuntime;

<PageTitle> Snake </PageTitle>
<img @ref="backgroundImage" id="bgImage" src="images/Background.png" alt="image" style="display:none;" />
<img @ref="wallImage" id="wallImage" src="images/Wall.png" alt="wall" style="display:none;" />
<!-- Snake Game Connection -->
<div style="padding: 10px; background-color: #f3f3f3;">
    <label>Server Address:</label>
    <input @bind="serverAddress" placeholder="Enter Server IP" style="margin-right: 5px;" />

    <label>Port Number:</label>
    <input @bind="portNumber" type="number" placeholder="Enter Port" style="margin-right: 5px;" />

    <label>Player Name:</label>
    <input @bind="playerName" placeholder="Enter Player Name" style="margin-right: 5px;" />

    <button @onclick="ConnectToServer">Connect</button>
    <button @onclick="DisconnectFromServer" style="margin-left: 5px;">Disconnect</button>

    <p>@statusMessage</p>
</div>

<!-- Snake Canvas with Top Margin -->
<div id="snakeCanvas" style="margin-top: 20px;">
    <BECanvas Width="1000" Height="1000" @ref="canvasReference"></BECanvas>
</div>

@code
{

    private BECanvasComponent canvasReference = null!;
    private Canvas2DContext context = null!;
    private IJSObjectReference jsModule = null!;

    private string serverAddress = "localhost"; // Default IP
    private int portNumber = 11000; // Default Port
    private string playerName = "";
    private string statusMessage = "";
    private NetworkController? networkController;

    /// <summary>
    /// C# reference to the html element for the background image
    /// </summary>
    private ElementReference backgroundImage;
    private ElementReference wallImage;
    private const int ViewWidth = 1000;
    private const int ViewHeight = 1000;
    private readonly string[] playerColors = { "cyan", "yellow", "blue", "orange", "purple", "pink", "lime", "green" };


    private void ConnectToServer()
    {
        if (string.IsNullOrWhiteSpace(playerName))
        {
            statusMessage = "Player name is required!";
            return;
        }
        if (playerName.Length > 16)
        {
            statusMessage = "Player name must be 16 characters or less.";
            return;
        }
        try
        {
            // Initialize networkController only when connecting
            networkController = new NetworkController(serverAddress, portNumber);
            networkController.OnError = errorMessage => statusMessage = errorMessage;
            networkController.OnDisconnected = DisconnectFromServer;

            networkController.SendPlayerName(playerName); // Send the player's name upon connecting
            statusMessage = $"Connected to {serverAddress}:{portNumber} as {playerName}.";
        }
        catch (Exception ex)
        {
            statusMessage = $"Failed to connect: {ex.Message}";
        }
    }

    private async void DisconnectFromServer()
    {
        if (networkController != null)
        {
            networkController.Close();
            statusMessage = "Disconnected from the server.";
            networkController = null;
        }
        else
        {
            statusMessage = "Disconnected from the server.";
        }
        await ClearCanvasLoop();
        await InvokeAsync(StateHasChanged);
    }



    protected override async Task OnAfterRenderAsync( bool firstRender )
    {
        if ( firstRender )
        {
            jsModule = await JsRuntime.InvokeAsync<IJSObjectReference>( "import", "./Pages/SnakeGUI.razor.js" );
            context = await canvasReference.CreateCanvas2DAsync();
            await JsRuntime.InvokeAsync<object>( "initRenderJS", DotNetObjectReference.Create( this ) );           

            GameLoop(); // Start the game loop
        }
    }

    private async void GameLoop()
    {
        while (true)
        {
            if (networkController?.TheWorld != null) // Only draw when TheWorld is initialized
            {
                await DrawFrame();
                //Console.WriteLine("Drawing frames");
            }
            await Task.Delay(20); // 50 FPS
        }
    }

    private async Task ClearCanvasLoop()
    {
        int clearDuration = 1000; // Duration in milliseconds
        int clearInterval = 100;  // Interval between clears in milliseconds
        int elapsed = 0;

        while (elapsed < clearDuration)
        {
            await ClearCanvas();
            await Task.Delay(clearInterval);
            elapsed += clearInterval;
        }
    }

    private async Task ClearCanvas()
    {
        if (context != null)
        {
            await context.ClearRectAsync(0, 0, ViewWidth, ViewHeight);
        }
    }


    private async Task DrawFrame()
    {
        // Exit early if TheWorld is not initialized yet
        if (networkController?.TheWorld == null)
        {
            return;
        }

        await context.BeginBatchAsync();

        // Clip the view to avoid drawing outside the canvas
        await context.BeginPathAsync();
        await context.RectAsync(0, 0, ViewWidth, ViewHeight);
        await context.ClipAsync();

        // Save the context state before applying transformations
        await context.SaveAsync();

        // Centering based on the player's head position
        if (networkController.TheWorld.Players.TryGetValue(networkController.playerID, out Player currentPlayer))
        {
            // Get the head coordinates of the player
            double headX = currentPlayer.Body.Last().X;
            double headY = currentPlayer.Body.Last().Y;

            // Calculate offsets to center the view on the player's head
            double offsetX = -(headX - (ViewWidth / 2));
            double offsetY = -(headY - (ViewHeight / 2));

            // Center on origin and move to player's head position
            await context.TranslateAsync(ViewWidth / 2, ViewHeight / 2);
            await context.TranslateAsync(-headX, -headY);

            // Set the scale and calculate the center offset for background centering
            double largeBackgroundSize = networkController.TheWorld.Size * 1.5; // Example: 1.5x world size for a buffer

            // Draw a larger solid background to avoid empty edges
            await context.SetFillStyleAsync("black"); // Or any background color you prefer
            await context.FillRectAsync( -largeBackgroundSize / 2, -largeBackgroundSize / 2, largeBackgroundSize, largeBackgroundSize);

            // Draw the image background:
            await context.DrawImageAsync(backgroundImage, -networkController.TheWorld.Size / 2, -networkController.TheWorld.Size / 2, networkController.TheWorld.Size, networkController.TheWorld.Size);
        }

        // Draw each player in TheWorld
        foreach (var player in networkController.TheWorld.Players.Values)
        {
            await DrawSnake(player);
        }

        // Draw each powerup in TheWorld
        foreach (var powerup in networkController.TheWorld.Powerups.Values)
        {
            await DrawPowerup(powerup);
        }

        // Draw each wall segment
        foreach (var wall in networkController.TheWorld.Walls.Values)
        {
            await DrawWall(wall);
        }

        // Restore the transformation matrix to the original state after drawing
        await context.RestoreAsync();

        await context.EndBatchAsync();
    }


    private async Task DrawSnake(Player player)
    {

        if (!player.Alive)
        {
            await context.SetStrokeStyleAsync("red"); // Use red for dead snakes
        }
        else
        {
            // Use a unique color for the first 8 players; reuse colors for others
            string color = player.ID < 8 ? playerColors[player.ID] : playerColors[player.ID % 8];
            await context.SetStrokeStyleAsync(color);
        }

        await context.SetLineWidthAsync(10); // Set line width for snake

        await context.BeginPathAsync();

        if (player.Body.Count > 0)
        {
            double startX = player.Body[0].X;
            double startY = player.Body[0].Y;
            await context.MoveToAsync(startX, startY);

            foreach (var segment in player.Body)
            {
                await context.LineToAsync(segment.X, segment.Y);
                //Console.WriteLine($"Drawing segment at ({segment.X}, {segment.Y})"); // Debugging
            }
        }

        await context.StrokeAsync();
    }

    private async Task DrawPowerup(Powerup powerup)
    {
        await context.SetFillStyleAsync("red");
        // Draw a 16x16 pixel powerup
        double powerupX = powerup.Position.X - 8; // Center 16x16 powerup on position
        double powerupY = powerup.Position.Y - 8;
        await context.FillRectAsync(powerupX, powerupY, 16, 16);
    }

    private async Task DrawWall(Wall wall)
    {
        // Calculate the distance between Point1 and Point2
        double deltaX = wall.Point2.X - wall.Point1.X;
        double deltaY = wall.Point2.Y - wall.Point1.Y;
        double distance = Math.Sqrt(deltaX * deltaX + deltaY * deltaY);

        // Calculate the number of 50x50 segments needed along the line
        int segmentCount = (int)(distance / 50);

        // Calculate the direction vector for each segment
        double stepX = deltaX / distance * 50;
        double stepY = deltaY / distance * 50;

        // Draw each 50x50 image segment along the line
        for (int i = 0; i < segmentCount + 1; i++)
        {
            double posX = wall.Point1.X + i * stepX - 25;
            double posY = wall.Point1.Y + i * stepY - 25;

            // Draw the wall image at each segment position
            await context.DrawImageAsync(wallImage, posX, posY, 50, 50);
        }
    }


    [JSInvokable]
    public void HandleKeyPress(string key)
    {
        if (networkController?.TheWorld == null)
        {
            return;
        }

        string direction = key switch
        {
            "w" => "up",
            "s" => "down",
            "a" => "left",
            "d" => "right",
            _ => "none"
        };

        if (direction != "none")
        {
            networkController.SendMoveCommand(direction);
        }

        Console.WriteLine("key pressed: " + key);
    }

}

